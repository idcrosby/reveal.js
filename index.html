<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Living the Continuous Delivery Dream</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Living the Continuous Delivery Dream</h2>
					<aside class="notes">
        				Who here currently is doing Continuous Integration? What about Continuous Delivery? And Continuous Deployment? ANd of those who did not raise your hands, does anyone feel that they shouldn't or don't want to implement CD?
        				Ok just want to make sure I'm not speaking to the wrong crowd.
        				Let's start with defining some terms.
    				</aside>
				</section>
				<section>
					<section>
						<h3>Continuous ... </h3>
						<aside class="notes">
							The goal here is continuity
						</aside>
					</section>
					<section>
						<h3>Continuous Integration</h3>
						<aside class="notes">
							Continuous Integration is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early.
							So many teams say we have Git, Unit Tests, and Jenkins. Great, we're doing CI. The tools themselves don't define the process. They enable you to adopt CI, but there is more required. You need to follow and buy in the paradigm.
						</aside>
					</section>
					<section>
						<h3>Continuous Deployment</h3>
						<aside class="notes">
							Continuous Deploymnet is in addition to CI, in which every change goes through your pipeline and automatically gets pushed into production. This results in several deployments to production per day.
						</aside>
					</section>
					<section>
						<h3>Continuous Delivery</h3>
						<aside class="notes">
							Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time. It aims at building, testing, and releasing software faster and more frequently.

							So Continuous Delivery implies all the same requirements as Continuous Deployment, but the push to production step is optional. We are able and confident to push each change in production, but we may not necessarily do so. The choice to release software is essentially a business decision.

							The focus of this talk is Continuous Delivery.
							I won’t go into the benefits of CD in this talk, these have been well established and there are plenty of blogs/papers/talks dispelling the many positives of implementing Continuous DeliveryAs , we are at the point where It is generally accepted that continuous delivery (if not continuous deployment) is where we should be as a mature software development team. So the logical question is why are we not all doing this already? We agree it’s the way forward, and understand the benefits and savings we’ll gain, so let’s implement this thing tomorrow!
						</aside>
					</section>
				</section>
				<section>
					<section data-transition="fade" data-markdown>
						<script type="text/template">
						```
							$apt-get install continuous-delivery
						```
						</script>
						^
					</section>
					<section data-transition="fade" data-markdown data-notes="Okay, that didn’t work. Because it’s not trivial to implement. Setting up a pipeline, migrating existing infrastructure, adding new tooling, all of this takes serious investment. And it can be hard to take the time out and/or to convince the necessary people to do this. So what I want to focus on is how we can use existing tools, such as Docker, Kubernetes, to help us get there.

					So let's jump back a little bit... how did we get here?">
						<script type="text/template">
						```
							$sudo apt-get install continuous-delivery
						```
						</script>
					</section>
				</section>
				<section>
					<h2>A long time ago, on a dev team far, far away...</h2>
					<aside class="notes">
						Back in ancient times we had this wonderful thing called waterfall, as developers we were blissful and ignorant, write some Fortran, compile it (or assemble or whatever the hell you do with Fortran) and I'm done! No longer my problem. we heave it over the proverbial wall and let the QA/Test/Ops guys deal with it.  And inevitably it wouldn’t work on the test or integration environment, and someone comes knocking at our desk. And our response:
					</aside>
				</section>
				<section>
					<section>
						<h2>"It works on my machine"</h2>
						<aside class="notes">
							[First]
							I don’t know what kind of crazy minecraft OS you’re running it on, but my code works. But that was the old way, we’re better than that now right? 
						</aside>
					</section>
					<section>
						<h1>Agile</h1>
						<aside class="notes">
							We’ve gone through agile and scrum eras and ...
						</aside>
					</section>
					<section>
						<h1>Dev Ops!</h1>
						<aside class="notes">
							We’re living in the dev ops period, so now when we toss the code over the wall, we’ve gotta run over there to catch it ourselves.
						</aside>
					</section>
					<section>
						<h2>It works on my machine</h2>
						<aside class="notes">
							Why is this not valid statement? if it works on my machine, why shouldn't it work in production? We're not bad developers. We write sensible code, usually, so if my application is running on my local environment and I'm happy with it, it should be reasonable to assume it can run in prod with confidence. So how do we get this confidence? 
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h3>Development == Production<span class="fragment"> ...ish</span></h3>
						<aside class="notes">
							I need to be running the same software on dev as I do on production. Not just the right version/branch/tag but using the same dependencies. So Docker helps to solve this problem for us, we build a Docker image which use for development testing, and we use the same image on testing/staging/production.  Docker in itself cannot solve this for us, but it helps. And that is the focus here, is that we now have tooling which makes Continuous Delivery easier to achieve.

							I need to run my software on the same OS, of the same version, with the same libraries, etc. Again, Docker helps us to sovle this, the image we build contains not just our code, but the OS as well.

							What about external dependencies. So databases, how do we ensure we are developing against the same database as we will run in production?  As we move into a micro services architecture, there are more and more dependencies which the specific service we are developing must interact with and depend on. Docker helps us in this case, but it does not completely solve the problem.
						</aside>
					</section>
				</section>
				<section>
					<h2>Orchestrate ALL the things!</h2>
					<aside class="notes">
						As we increase the number of dependancies and the number of containers we need some sort of orchestration tool to maintain consistency within and across our environments. There are many of these tools available, I will take a look at Kubernetes as well as Red Hat’s OpenShift platform which is built on top of k8s.
					</aside>
				</section>
				<section>
					<h3>Kubernetes</h3>
					<img src="img/kubernetes.png" style="border-style: none">
					<aside class="notes">
						I assume most people are already familiar with Kubernetes? For those who aren't, it's basically an orchestration platform for Containers. 
					</aside>
				</section>
				<section>
					<h3>OpenShift</h3>
					<img src="img/openshift.png" style="border-style: none">
					<aside class="notes">
						If you were at the Docker meetup back in November, Alessandro gave an introduction to OpenShift. For those not familiar with OpenShift, it is Red Hat's PaaS built on top of Kubernetes.
					</aside>
				</section>
				<section>
					<h1><a href="https://10.1.2.2:8443/" target="_blank">Demo</a></h1>
					<aside class="notes">
						I've seen many people pray to the demo gods, only to have those demos crash and burn. So I've actually become Demo God Agnostic. No prayers, no sacrifices...
					</aside>
				</section>
				<section>
					<h2>We're Hiring</h2>
					<img src="img/cs-logo.png" height="200" style="border-style: none">
					<aside class="notes">
						yup. 
					</aside>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
